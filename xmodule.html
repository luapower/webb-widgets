<!DOCTYPE html>
<html>
<head>
<title>X-MODULE</title>
<meta charset="utf-8">
<style>

html, body {
	position: relative;
	margin: 0;
	height: 100%;
	display: grid;
}

* { box-sizing: border-box; }

@font-face {
	font-family: "x-widget";
	src: url("/OpenSans-Regular.ttf");
}

@font-face {
	font-family: "x-widget";
	src: url("/OpenSans-SemiBold.ttf");
	font-weight: bold;
}

</style>

<script src="ace.js" integrity="sha256-+svOVB1WmhKhTy7N21gWvtyXn91qF0r52P2hIArRRug="></script>

<link rel="stylesheet" type="text/css" href="fontawesome.css">
<link rel="stylesheet" type="text/css" href="x-widgets.css">

<script src="glue.js"></script>
<script src="divs.js"></script>
<script src="ajax.js"></script>
<script src="url.js"></script>
<script src="x-widgets.js"></script>
<script src="x-rowset-widget.js"></script>
<script src="x-listbox.js"></script>
<script src="x-grid.js"></script>
<script src="x-calendar.js"></script>
<script src="x-country-dropdown.js"></script>
<script src="x-cssgrid.js"></script>

</head>

<body>
<script>

// ---------------------------------------------------------------------------
// rowset types
// ---------------------------------------------------------------------------

rowset.types.rowset = {}

rowsets_rowset = global_rowset('rowsets')
rowsets_rowset.load()

rowset.types.rowset.editor = function(...options) {
	return list_dropdown(update({
		nolabel: true,
		lookup_rowset: rowsets_rowset,
	}, ...options))
}

rowset.types.rowset_field = {}

rowset.types.rowset_field.editor = function(...options) {
	let e = list_dropdown(update({
		nolabel: true,
		lookup_rowset: rowset({
			fields: [{name: 'name'}],
		}),
	}, ...options))
	let rs_field = e.nav.rowset.field(this.rowset_col)
	let rs_name = e.nav.rowset.value(e.nav.focused_row, rs_field)
	let rs = rs_name && global_rowset(rs_name)
	if (rs) {
		rs.once('loaded', function() {
			let rows = rs.fields.map((field) => [field.name])
			e.lookup_rowset.reset({
				rows: rows,
			})
		})
		rs.load_fields()
	}
	return e
}

// ---------------------------------------------------------------------------
// property inspector
// ---------------------------------------------------------------------------

prop_inspector = component('x-prop-inspector', function(e) {

	grid.construct(e)

	e.vertical = true

	e.exit_edit_on_lost_focus = false
	e.can_sort_rows = false
	e.enable_context_menu = false
	e.focus_cell_on_click_header = true

	// prevent getting out of edit mode.
	e.auto_edit_first_cell = true
	e.enter_edit_on_click = true
	e.exit_edit_on_escape = false
	e.exit_edit_on_enter = false
	e.stay_in_edit_mode = true

	e.rowset = rowset({
		can_change_rows: true,
	})

	init = e.init
	e.init = function() {
		init_rowset(e.widget)
		init()
	}

	function bind(on) {
		document.on('prop_changed', prop_changed, on)
	}
	e.on('attach', function() { bind(true) })
	e.on('detach', function() { bind(false) })

	e.rowset.on('val_changed', function(row, field, val) {
		e.widget[field.name] = val
	})

	function prop_changed(k, v, v0, ev) {
		return // TODO
		tree_tb.widget = ev.target
		if (e.widget != ev.target) {
			print('could not select widget in tree')
			return
		}
		let field = e.rowset.field(k)
		e.focus_cell(0, e.field_index(field))
		e.rowset.reset_val(e.focused_row, field, v)
	}

	e.on('exit_edit', function(ri, fi) {
		let field = e.fields[fi]
		e.rowset.reset_val(e.rows[ri], field, e.widget[field.name])
	})

	let widget
	e.property('widget',
		function() { return widget },
		function(v) {
			if (v == widget)
				return
			widget = v
			if (e.initialized)
				init_rowset(v)
		}
	)

	function init_rowset(widget) {
		let res = {}
		res.fields = []
		let vals = []
		res.rows = [vals]
		if (widget) {
			for (let prop in widget.props) {
				res.fields.push(widget.props[prop])
				vals.push(widget[prop])
			}
		}
		e.rowset.reset(res)
	}

})

// ---------------------------------------------------------------------------
// main app
// ---------------------------------------------------------------------------

body = document.body

function xmodule_load() {
	function loaded(t) {
		if (root_widget)
			root_widget.remove()
		root_widget	= component.create(t)
		body.add(root_widget)
		body.fire('widget_tree_changed')
	}
	ajax({url: '/xmodule.json', success: loaded}).send()
}

function xmodule_save() {
	ajax({url: '/xmodule.json', upload: root_widget.serialize()}).send()
}

body.on('keydown', function(key, shift, ctrl) {
	if (key == 's' && ctrl) {
		xmodule_save()
		return false
	}
	if (key == 'F5') {
		xmodule_load()
		return false
	}

})

root_widget = widget_placeholder()
body.add(root_widget)

xmodule_load()

function properties_toolbox(tb_opt, insp_opt) {
	let pg = prop_inspector(insp_opt)
	let tb = toolbox(update({
		title: 'properties',
		content: pg,
	}, tb_opt))
	tb.inspector = pg
	return tb
}

function tree_toolbox(tb_opt) {

	function widget_tree_rows() {
		let rows = new Set()
		function add_widget(e, pe) {
			if (!e) return
			rows.add([e, pe])
			if (e.child_widgets)
				for (let ce of e.child_widgets())
					add_widget(ce, e)
		}
		add_widget(root_widget)
		return rows
	}

	function widget_name(e) {
		return e.typename.replace('_', ' ')
	}

	let rs = rowset({
		fields: [
			{name: 'widget', format: widget_name},
			{name: 'parent_widget', visible: false},
		],
		rows: widget_tree_rows(),
		pk: 'widget',
		parent_col: 'parent_widget',
	})

	let g = grid({
		rowset: rs,
		tree_col: 'widget',
		header_visible: false,
		auto_focus_first_cell: false,
	})
	g.on('focused_row_changed', function(row, row0) {
		let e = row && row[0]
		let e0 = row0 && row0[0]
		if (e0)
			e0.editing = false
		props_tb.inspector.widget = e
		if (e)
			e.editing = true
	})

	let tb = toolbox(update({
		title: 'widget tree',
		content: g,
	}, tb_opt))

	g.auto_focus_first_cell = true
	g.init_focused_cell()

	function element_focusin(ev) {
		let e = ev.target
		while (e && !e.typename)
			e = e.popup_target || e.parent
		let pe = e.popup_target || e.parent
		while (pe && pe.typename != 'toolbox')
			pe = pe.popup_target || pe.parent
		if (e && e.typename && window.tree_tb && !(pe && pe.typename == 'toolbox'))
			tb.widget = e
	}

	function widget_tree_changed() {
		rs.reset({rows: widget_tree_rows()})
	}

	function bind(on) {
		document.on('focusin', element_focusin, on)
		document.on('widget_tree_changed', widget_tree_changed, on)
	}
	tb.on('attach', function() { bind(true) })
	tb.on('detach', function() { bind(false) })
	bind(true)

	function get_widget() {
		return e.focused_row && e.focused_row[0]
	}
	function set_widget(widget) {
		let row = rs.lookup(rs.field(0), widget)
		let ri = g.row_index(row)
		g.focus_cell(ri, 0)
	}
	tb.property('widget', get_widget, set_widget)

	return tb
}

function widgets_toolbox() {
	let lb = listbox({
		items: [
			'button', 'checkbox', 'radiogroup',
			'input', 'spin_input', 'slider',
			'list_dropdown', 'date_dropdown', 'grid_dropdown',
			'listbox', 'grid',
			'split', 'pagelist', 'cssgrid',
		],
	})
	let tb = toolbox({
		title: 'widgets',
		content: lb,
	})
	tb.on('dblclick', function(ev) {
		let i = ev.target.index
		let name = lb.items[i]
		let cons = window[name]
		let e = cons()
		body.add(e)
	})
	return tb
}


widgets_tb = widgets_toolbox({
	y: 150,
	x: 500,
})
//widgets_tb.show()

props_tb = properties_toolbox({
	y: 520,
	x: 400,
	w: 250,
	h: 400,
})
props_tb.show(true, true)

tree_tb = tree_toolbox({
	y: 520,
	x: 660,
	w: 200,
	h: 400,
})
tree_tb.show(true, true)

</script>
</body>
</html>
