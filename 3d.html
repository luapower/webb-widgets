<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<script src=glue.js></script>
<script src=divs.js></script>
<script src=3d.js></script>
<script src=gl.js></script>
<script src=earcut.js></script>
</head>
<body>
<canvas id=canvas width=640 height=640></canvas>
<script>

canvas.on('webglcontextlost', function() {
	assert(false, 'webgl context lost')
})

let gl = canvas.getContext('webgl2')

gl.module('selected_face.vs', `
	in float selected;
	flat out float frag_selected;
	void selected_face() {
		frag_selected = selected;
	}
`)

gl.module('selected_face.fs', `
	flat in float frag_selected;
	void selected_face() {
		if (frag_selected == 1.0) {
			float x = mod(gl_FragCoord.x, 4.0);
			float y = mod(gl_FragCoord.y, 8.0);
			if ((x >= 0.0 && x <= 1.1 && y >= 0.0 && y <= 0.5) ||
				 (x >= 2.0 && x <= 3.1 && y >= 4.0 && y <= 4.5))
				frag_color = vec4(0.0, 0.0, .8, 1.0);
		}
	}
`)

// face material -------------------------------------------------------------

function face_program(gl) {

	let vs = `
		#include base.vs
		#include phong.vs
		#include shadows.vs
		#include selected_face.vs
		void main() {
			phong();
			shadows();
			selected_face();
		}
	`

	let fs = `
		#include base.fs
		#include phong.fs
		#include shadows.fs
		#include selected_face.fs
		void main() {
			phong();
			shadows();
			selected_face();
		}
	`

	let pr = gl.program('face', vs, fs)

	return pr
}

// scene ---------------------------------------------------------------------

// geometry

let points = [
	 0,  0, -1,
	 2,  0, -1,
	 2,  2,  0,
	 0,  2,  0,
	 0,  0,  2,
	 2,  0,  2,
	 2,  2,  2,
	 0,  2,  2,
]

{
let _p = v3()
face3 = poly3.subclass({
	get_point: function(pi, p) {
		return (p || _p).from_array(points, 3 * this[pi])
	},
})
}


let faces = [
	face3({uvm: mat3().translate(.1, .1).scale(1)}, [1, 0, 3, 2]),
	face3({uvm: mat3().scale(1).invert()}, [4, 5, 6, 7]),
	face3({uvm: mat3().scale(1).invert()}, [7, 6, 2, 3]), //[6, 2, 3],
	face3({uvm: mat3().scale(1).invert()}, [4, 0, 1, 5]),
	face3({uvm: mat3().scale(1).invert()}, [0, 4, 7, 3]),
	face3({uvm: mat3().scale(1).invert()}, [5, 1, 2, 6]),
]

let triangles = []
let normals = []
let uvs = []
let selected = []

let _p = v3()

for (let face of faces) {
	face.tris = []
	face.triangulate(face.tris, Number.EPSILON)
	let no = face.plane().normal
	let p0 = face.get_point(0, _p)
	for (let i = 0, n = face.tris.length; i < n; i++) {
		let p = face.get_point(face.tris[i])
		triangles.push(p.x, p.y, p.z)
		normals.push(no.x, no.y, no.z)
		let uv = face.uv_at(face.tris[i], face.uvm, v2(1, 1))
		uvs.push(uv.x, uv.y)
		selected.push((triangles.length - 4) % 12 >= 6 ? 1 : 0)
	}
}

function scale_texture(tex) {
	let pi = 0
	for (let face of faces) {
		for (let i = 0; i < face.tris.length; i++) {
			let uv = face.uv_at(face.tris[i], face.uvm, tex.uv)
			uvs_dbuf.set(pi, uv)
			pi++
		}
	}
	uvs_dbuf.invalidate()
}

let    points_dbuf = gl.dyn_v3_buffer(points)
let triangles_dbuf = gl.dyn_v3_buffer(triangles)
let   normals_dbuf = gl.dyn_v3_buffer(normals)
let       uvs_dbuf = gl.dyn_v2_buffer(uvs)
let  selected_dbuf = gl.dyn_u8_buffer(selected)

let inst_mat1 = mat4()
			.translate(0, 1, 0)
			//.rotate(rad(-20), 0, 1, 0)

let inst_mat2 = mat4()
			.translate(0, -3, 0)
			//.rotate(rad( 45), 0, 1, 0)

let inst_mat_dbuf = gl.dyn_mat4_instance_buffer([
		...inst_mat1,
		...inst_mat2,
])

let lines = [
	0, 1,  1, 2,  2, 3,  3, 0,
]
let line_pis_buf = gl.dyn_index_buffer(lines)

// camera

let proj      = mat4f32()
let view      = mat4f32()
let view_proj = mat4f32()
let inv_proj  = mat4()
let inv_view  = mat4()

let view_pos    = v3(3, 3, 10)
let view_target = v3(0, 0, 0)
let view_up     = v3(0, 1, 0)

function update_camera() {

	gl.set_uni('view_pos', view_pos)

	view.reset()
		.translate(view_pos)
		.look_at(view_pos, view_target, view_up)
		//.scale(.5)
		.invert()
	inv_view.set(view).invert()
	gl.set_uni('view', view)

	mat4.mul(proj, view, view_proj)
	gl.set_uni('view_proj', view_proj)

}

function update_viewport_size() {
	let w = gl.canvas.cw
	let h = gl.canvas.ch
	gl.set_uni('viewport_size', w, h)
	update_proj()
}

function update_proj() {
	let w = gl.canvas.cw
	let h = gl.canvas.ch
	//proj.frustum(-1, 1, -1, 1, 3, 1e6)
	//proj.ortho(-1, 1, -1, 1, -1e2, 1e2).scale(.3)
	proj.perspective(rad(45), w / h, 0.01)
	inv_proj.set(proj).invert()
	gl.set_uni('proj', proj)
	update_camera()
}

function canvas_resized() {
	update_viewport_size()
}

canvas_resized()

document.on('wheel', function(ev, dy, mx, my) {
	let ray = gl.raycast(mx, my, inv_proj, inv_view)

	let d = view_pos.clone().sub(view_target)
	let len = max(0.01, d.len() * (1 + .2 * dy / 100))
	d.set_len(len)
	view_pos.set(view_target).add(d)
})

document.on('keydown', function(key) {
	print(key)
})

// materials & textures

let face_pr = face_program(gl)
let dashed_line_pr = gl.dashed_line_program()
let fat_line_pr = gl.fat_line_program()

let tex1 = gl.load_texture('checker-big.png', 0.001, scale_texture)

// rendering

gl.set_uni('sunlight_pos', 0, 10, 0)
gl.set_uni('sunlight_color', 1, 1, 1)
gl.set_uni('diffuse_color', 1, 1, 1, 1)

let rot = 0

function draw_scene(for_shadows) {
	rot += 0.05

	let radius = 10

	inst_mat1
		.reset()
		.translate(0, 1, 0)
		.rotate(-20 + rad(20*rot), 0, 1, 0)
	inst_mat_dbuf.set(0, inst_mat1)

	//view_pos.x = sin(rot/10) * radius
	//view_pos.y = sin(rot/10) * radius
	//view_pos.z = cos(rot/10) * radius
	update_camera()

	gl.clear_all(1, 1, 1)

	//pos_dbuf.array[0] = rot += 0.01
	//pos_dbuf.invalidate(0, 1)

	face_pr.use()
	face_pr.set_uni ('ambient_strength' , 0.1)
	face_pr.set_uni ('specular_strength', .2)
	face_pr.set_uni ('shininess'        , 1 << 5) // keep this a pow2.
	face_pr.set_uni ('diffuse_map'      , tex1)
	face_pr.set_attr('model'            , inst_mat_dbuf.buffer())
	face_pr.set_attr('pos'              , triangles_dbuf.buffer())
	face_pr.set_attr('normal'           , normals_dbuf.buffer())
	face_pr.set_attr('uv'               , uvs_dbuf.buffer())
	face_pr.set_attr('selected'         , selected_dbuf.buffer())
	gl.polygonOffset(.0001, 0)
	gl.draw_triangles()
	gl.polygonOffset(0, 0)

	dashed_line_pr.use()
	dashed_line_pr.set_uni ('color' , 1, 0, 1, 1)
	dashed_line_pr.set_uni ('dash'  , 2)
	dashed_line_pr.set_uni ('gap'   , 4)
	dashed_line_pr.set_attr('model' , inst_mat_dbuf.buffer())
	dashed_line_pr.set_attr('pos'   , points_dbuf.buffer())
	dashed_line_pr.set_index(line_pis_buf.buffer())
	gl.draw_lines()

	fat_line_pr.set_points([
		line3(v3(0, 0, 0), v3(0, 0, 1)),
		line3(v3(0, 0, 0), v3(0, 1, 0)),
		line3(v3(0, 0, 0), v3(1, 0, 0)),
	])
	fat_line_pr.use()
	fat_line_pr.set_uni('color', 0, 0, 0, 1)
	fat_line_pr.draw()

}

let shadow_map = gl.shadow_map({
	draw_scene: draw_scene,
})

function animate() {
	shadow_map.render()
	gl.end_frame()
	raf(animate)
}

animate()

</script>
</body>
</html>
