<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<script src=glue.js></script>
<script src=divs.js></script>
<script src=3d.js></script>
<script src=earcut.js></script>
<script src=gl.js></script>
<script src=skp.js></script>
</head>
<body>
<canvas style="border: 1px solid black" id=canvas width=640 height=640></canvas>
<script>
{

canvas.on('webglcontextlost', function() {
	assert(false, 'webgl context lost')
})

let gl = canvas.getContext('webgl2', {
	//antialias: false, // MSAA FBOs can't be blitted to a MSAA canvas.
})

gl.module('selected_face.vs', `

	in float selected;
	flat out float frag_selected;

	void do_selected_face() {
		frag_selected = selected;
	}

`)

gl.module('selected_face.fs', `

	flat in float frag_selected;

	void do_selected_face() {
		if (frag_selected == 1.0) {
			float x = mod(gl_FragCoord.x, 4.0);
			float y = mod(gl_FragCoord.y, 8.0);
			if ((x >= 0.0 && x <= 1.1 && y >= 0.0 && y <= 0.5) ||
				 (x >= 2.0 && x <= 3.1 && y >= 4.0 && y <= 4.5))
				frag_color = vec4(0.0, 0.0, .8, 1.0);
		}
	}

`)

// face material -------------------------------------------------------------

function face_program(gl) {
	return gl.program('face', `
		#include mesh.vs
		#include phong.vs
		#include selected_face.vs
		void main() {
			do_phong();
			do_selected_face();
		}
	`, `
		#include mesh.fs
		#include phong.fs
		#include selected_face.fs
		void main() {
			do_phong();
			do_selected_face();
		}
	`)
}

// scene ---------------------------------------------------------------------

// geometry

let points = [
	 0,  0,  0,
	 2,  0,  0,
	 2,  2,  0,
	 0,  2,  0,
	 0,  0,  2,
	 2,  0,  2,
	 2,  2,  2,
	 0,  2,  2,
]

{
let _p = v3()
face3 = poly3.subclass({
	get_point: function(pi, p) {
		return (p || _p).from_array(points, 3 * this[pi])
	},
})
}


let faces = [
	face3({uvm: mat3().translate(.1, .1).scale(1)}, [1, 0, 3, 2]),
	face3({uvm: mat3().scale(1).invert()}, [4, 5, 6, 7]),
	face3({uvm: mat3().scale(1).invert()}, [7, 6, 2, 3]), //[6, 2, 3],
	face3({uvm: mat3().scale(1).invert()}, [4, 0, 1, 5]),
	face3({uvm: mat3().scale(1).invert()}, [0, 4, 7, 3]),
	face3({uvm: mat3().scale(1).invert()}, [5, 1, 2, 6]),
]

let triangles = []
let triangle_pis = []
let normals = []
let uvs = []
let selected = []
let face_ids = []
let inst_ids = []

let _p = v3()

let face_id = 1 // gotta start at 1...
for (let face of faces) {
	face.tris = []
	face.triangulate(face.tris)
	let no = face.plane().normal
	let p0 = face.get_point(0, _p)
	for (let i = 0, n = face.tris.length; i < n; i++) {
		triangle_pis.push(face[face.tris[i]])
		let p = face.get_point(face.tris[i])
		triangles.push(p.x, p.y, p.z)
		face_ids.push(face_id)
		normals.push(no.x, no.y, no.z)
		let uv = face.uv_at(face.tris[i], face.uvm, v2(1, 1))
		uvs.push(uv.x, uv.y)
		selected.push((triangles.length - 4) % 12 >= 6 ? 1 : 0)
	}
	face_id++
}

function scale_texture(tex) {
	let pi = 0
	for (let face of faces) {
		for (let i = 0; i < face.tris.length; i++) {
			let uv = face.uv_at(face.tris[i], face.uvm, tex.uv)
			uv.to_array(uvs, 2*pi)
			pi++
		}
	}
	uvs_dbuf.buffer.upload(uvs)
}

let inst_mat1 = mat4()

let inst_mats = [
	...inst_mat1,
	...mat4().translate(  0,   0,   0),
	...mat4().translate( 10,   0,   0),
	...mat4().translate(  0,  10,   0),
	...mat4().translate( 10,  10,   0),
	...mat4().translate(  0,   0, -10),
	...mat4().translate( 10,   0, -10),
	...mat4().translate(  0,  10, -10),
	...mat4().translate( 10,  10, -10),
]

for (let i = 0; i < inst_mats.length / 16; i++)
	inst_ids[i] = i+1

let    points_dbuf = gl.dyn_v3_buffer(points)
let triangles_dbuf = gl.dyn_v3_buffer(triangles)
let   normals_dbuf = gl.dyn_v3_buffer(normals)
let       uvs_dbuf = gl.dyn_v2_buffer(uvs)
let  selected_dbuf = gl.dyn_u8_buffer(selected)
let  face_ids_dbuf = gl.dyn_u32_buffer(face_ids)
let  inst_ids_dbuf = gl.dyn_u32_instance_buffer(inst_ids)

let inst_mat_dbuf = gl.dyn_mat4_instance_buffer(inst_mats)

let lines = [
	0, 1,  1, 2,  2, 3,  3, 0,
]
let line_pis_buf = gl.dyn_index_buffer(lines)

let camera = camera3()

let skybox

function update_camera() {

	gl.set_uni('view_pos', camera.pos)
	gl.set_uni('view', camera.view)
	gl.set_uni('view_proj', camera.view_proj)

	if (skybox)
		skybox.update_view(camera.pos)

}

function update_viewport_size() {
	let w = gl.canvas.cw
	let h = gl.canvas.ch
	gl.set_uni('viewport_size', w, h)
	//camera.frustum(-1, 1, -1, 1, 3, 1e6)
	//camera.ortho(-1, 1, -1, 1, -1e2, 1e2).scale(.3)
	//camera.ortho(-10, 10, -10, 10, -1e2, 1e2)
	camera.viewport_w = w
	camera.viewport_h = h
	camera.perspective()
	camera.update()
	gl.set_uni('proj', camera.proj)
	update_camera()
}

function canvas_resized() {
	update_viewport_size()
}

canvas_resized()

//camera.pos.set(10, 10, 10)
//camera.dir.set(.4, .2, 1)
//camera.update()

function hit_test(mx, my) {
	let ray = camera.raycast(mx, my, line3())
	let [inst_id, face_id] = face_id_renderer.hit_test(mx, my)
	if (inst_id && face_id) {
		let model = mat4().from_mat4_array(inst_mats, inst_id-1)
		let inv_model = mat4().set(model).invert()
		ray.transform(inv_model)
		let face = faces[face_id-1]
		let target = face.plane().intersect_line(ray, null, v3())
		return target && target.transform(model)
	} else {
		return ray.at(min(FAR / 10, camera.pos.len()), v3())
	}
}

canvas.on('pointerdown', function(ev, mx0, my0) {
	let r = canvas.rect()
	mx0 -= r.x
	my0 -= r.y
	let target = hit_test(mx0, my0)
	if (!target)
		return
	let cam0 = camera.clone()
	return canvas.capture_pointer(ev, function(ev, mx, my) {
		mx -= r.x
		my -= r.y
		let dx = mx - mx0
		let dy = my - my0
		camera.set(cam0)
		if (ev.shiftKey) {
			camera.pan(target, mx0, my0, mx, my)
		} else {
			camera.orbit(target, dy / 200, dx / 200, 0)
		}
		camera.update()
	})
})

canvas.on('wheel', function(ev, dy, mx, my) {
	let r = canvas.rect()
	mx -= r.x
	my -= r.y
	let target = hit_test(mx, my)
	if (target) {
		camera.dolly(target, 1 + 0.2 * (dy / 100))
		camera.update()
	}
})

document.on('keydown', function(key) {
	print(key)
})

// materials & textures

let face_vao = face_program(gl).vao()
let dashed_line_vao = gl.dashed_line_program().vao()
let fat_line_vao = gl.fat_line_vao()

let tex1 = gl.texture().load('checker-big.png', 0.001, scale_texture)

// rendering

let tq
function draw_faces(sdm_vao) {

	if (sdm_vao) {
		sdm_vao.set_attr('pos'  , triangles_dbuf.buffer)
		sdm_vao.set_attr('model', inst_mat_dbuf.buffer)
		sdm_vao.set_attr('face_id', face_ids_dbuf.buffer)
		sdm_vao.set_attr('inst_id', inst_ids_dbuf.buffer)
		sdm_vao.use()
	} else {
		face_vao.set_uni ('ambient_strength' , 0.1)
		face_vao.set_uni ('specular_strength', .2)
		face_vao.set_uni ('shininess'        , 1 << 5) // keep this a pow2.
		face_vao.set_uni ('diffuse_map'      , tex1)
		face_vao.set_attr('pos'              , triangles_dbuf.buffer)
		face_vao.set_attr('normal'           , normals_dbuf.buffer)
		face_vao.set_attr('uv'               , uvs_dbuf.buffer)
		face_vao.set_attr('selected'         , selected_dbuf.buffer)
		face_vao.set_attr('model'            , inst_mat_dbuf.buffer)
		face_vao.use()
	}

	gl.polygonOffset(.0001, 0)
	gl.draw_triangles()
	gl.polygonOffset(0, 0)

	gl.active_vao.unuse()

	if (0) {
		depth_map.uv = v2(2, 2)
		assert(!gl.active_fbo)
		tq = tq || gl.texture_quad(depth_map)
		tq.model.reset().scale(5).translate(0, 0, -1)
		tq.update_model()
		tq.draw()
	}
}

function draw_dashed_lines() {
	let vao = dashed_line_vao
	vao.set_uni ('color' , 1, 0, 1, 1)
	vao.set_uni ('dash'  , 2)
	vao.set_uni ('gap'   , 4)
	vao.set_attr('model' , inst_mat_dbuf.buffer)
	vao.set_attr('pos'   , points_dbuf.buffer)
	vao.set_index(line_pis_buf.buffer)
	vao.use()
	gl.draw_lines()
	vao.unuse()
}

function draw_fat_lines() {
	let vao = fat_line_vao
	vao.set_points([
		line3(v3(0, 0, 0), v3(0, 0, 1)),
		line3(v3(0, 0, 0), v3(0, 1, 0)),
		line3(v3(0, 0, 0), v3(1, 0, 0)),
	])
	vao.set_uni('color', 0, 0, 0, 1)
	vao.draw()
}

function draw_lines() {
	draw_dashed_lines()
	//draw_fat_lines()
}

let rot = 0

function start_frame() {

	rot += 0.05
	let radius = 10

	inst_mat1
		.reset()
		.translate(0, 3, 0)
		.rotate(v3.up, -20 + rad(20*rot))
	inst_mat_dbuf.buffer.upload(inst_mat1, 0)

	//camera.dir.x = sin(rot/10) * radius
	//camera.pos.y = sin(rot/10) * radius
	//camera.dir.z = cos(rot/10) * radius
	camera.update()
	//camera.dolly(v3(11, 2, -9), .99)
	update_camera()

	//pos_dbuf.array[0] = rot += 0.01
	//pos_dbuf.invalidate(0, 1)
}

let renderer = gl.renderer({
	sunlight_dir: v3.up.clone(),
	enable_shadows: true,
})

let face_id_renderer = gl.face_id_renderer()

skybox = gl.skybox({
	images: {
		//right  : 'skybox/right.jpg',
		//left   : 'skybox/left.jpg',
		//top    : 'skybox/top.jpg',
		//bottom : 'skybox/bottom.jpg',
		//front  : 'skybox/front.jpg',
		//back   : 'skybox/back.jpg',

		posx: 'skybox/posx.jpg',
		negx: 'skybox/negx.jpg',
		posy: 'skybox/posy.jpg',
		negy: 'skybox/negy.jpg',
		posz: 'skybox/posz.jpg',
		negz: 'skybox/negz.jpg',
	},
})

let axes = gl.axes()

axes.upload_model(axes.add_instance(), mat4f32())

function draw_all(sdm_vao) {
	if (!sdm_vao)
		skybox.draw()
	axes.draw()
	draw_faces(sdm_vao)
	draw_lines(sdm_vao)
}

function animate() {
	start_frame()
	renderer.sunlight_dir.set(camera.dir)
	renderer.update()
	renderer.render(draw_all)
	face_id_renderer.render(draw_faces)
	raf(animate)
}

canvas.on('pointermove', function(ev, mx, my) {
	let r = this.rect()
	mx -= r.x
	my -= r.y
	let [inst_id, face_id] = face_id_renderer.hit_test(mx, my)

	//print(...camera.screen_to_view(mx, my, 1))
})

animate()

} // module scope (avoid BS js error about let redeclaration).
</script>
</body>
</html>
